document.addEventListener('DOMContentLoaded', function() {
    const track = document.querySelector('.carousel-track');
    if (!track) return;

    const slides = Array.from(track.children);
    const nextButton = document.querySelector('.carousel-btn.next');
    const prevButton = document.querySelector('.carousel-btn.prev');
    const dotsNav = document.querySelector('.carousel-indicators');
    const dots = Array.from(dotsNav.children);

    const slideWidth = slides[0].getBoundingClientRect().width;

    // Arrange the slides next to one another
    const setSlidePosition = (slide, index) => {
        slide.style.left = slideWidth * index + 'px';
    };
    // We don't need absolute positioning if we use flexbox on track, 
    // but let's stick to a simple transform logic.
    // Actually, with flexbox (display: flex on track), we just need to translate the track.
    
    let currentSlideIndex = 0;

    const updateSlidePosition = () => {
        const amountToMove = -100 * currentSlideIndex;
        track.style.transform = `translateX(${amountToMove}%)`;
    }

    const updateDots = (currentDot, targetDot) => {
        currentDot.classList.remove('current-slide');
        targetDot.classList.add('current-slide');
    }

    let autoPlayInterval;

    const resetTimer = () => {
        clearInterval(autoPlayInterval);
        autoPlayInterval = setInterval(() => {
            // We need to manually trigger the next slide logic or simulate a click
            // However, since we are adding resetTimer to the click event, 
            // we should avoid calling click() here if we want to avoid infinite recursion 
            // IF the click handler was synchronous and blocking, but it's not.
            // But to be safe and cleaner, let's extract the next slide logic or just use a flag?
            // Actually, calling click() is fine because it's an event dispatch.
            // But to avoid the "event generated by script" vs "user" distinction complexity,
            // let's just let the click handler handle the reset.
            
            // But wait, if I call click(), the handler runs, calls resetTimer(), which clears THIS interval and sets a new one.
            // That is exactly what we want.
            
            // However, we need to make sure we don't pass the 'e' object issues if we were using it, but we are just using it for targetDot in dotsNav.
            // For next/prev buttons we don't use 'e'.
            
            // There is one small caveat: if the user clicks, we reset. If the timer clicks, we reset.
            // This is consistent.
            
            // But we need to be careful about the `e.isTrusted` if we wanted to distinguish, but we don't need to.
            
            // Let's just use a separate function for "go to next slide" to avoid circular dependency in thought, 
            // although technically safe. 
            // Actually, simply moving the logic out is better.
            
            moveToNextSlide();
        }, 8000);
    };

    const moveToNextSlide = () => {
        const currentDot = dotsNav.querySelector('.current-slide');
        let nextDot;

        if (currentSlideIndex === slides.length - 1) {
            currentSlideIndex = 0;
            nextDot = dots[0];
        } else {
            currentSlideIndex++;
            nextDot = currentDot.nextElementSibling;
        }
        
        updateSlidePosition();
        updateDots(currentDot, nextDot);
    }

    // Next Button
    nextButton.addEventListener('click', e => {
        moveToNextSlide();
        resetTimer();
    });

    // Prev Button
    prevButton.addEventListener('click', e => {
        const currentDot = dotsNav.querySelector('.current-slide');
        let prevDot;

        if (currentSlideIndex === 0) {
            currentSlideIndex = slides.length - 1;
            prevDot = dots[dots.length - 1];
        } else {
            currentSlideIndex--;
            prevDot = currentDot.previousElementSibling;
        }

        updateSlidePosition();
        updateDots(currentDot, prevDot);
        resetTimer();
    });

    // Dot Nav
    dotsNav.addEventListener('click', e => {
        const targetDot = e.target.closest('button');
        if (!targetDot) return;

        const currentDot = dotsNav.querySelector('.current-slide');
        const targetIndex = dots.findIndex(dot => dot === targetDot);

        currentSlideIndex = targetIndex;
        updateSlidePosition();
        updateDots(currentDot, targetDot);
        resetTimer();
    });

    // Start Auto play
    resetTimer();
});
